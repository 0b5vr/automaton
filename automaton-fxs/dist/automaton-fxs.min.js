// (c) 2020 FMS_Cat - https://github.com/FMS-Cat/automaton/blob/master/LICENSE
!function(e,a){"object"==typeof exports&&"undefined"!=typeof module?a(exports):"function"==typeof define&&define.amd?define(["exports"],a):a((e="undefined"!=typeof globalThis?globalThis:e||self).AUTOMATON_FXS={})}(this,(function(e){"use strict";const a={name:"Add",description:"The simplest fx ever. Just add a constant value to the curve.",params:{value:{name:"Value",type:"float",default:1}},func:e=>e.value+e.params.value},t={name:"Critically Damped Spring",description:"Basically the best smoothing method. Shoutouts to Keijiro Takahashi",params:{factor:{name:"Factor",type:"float",default:100,min:0},ratio:{name:"Damp Ratio",type:"float",default:1},preserve:{name:"Preserve Velocity",type:"boolean",default:!1}},func(e){const a=e.deltaTime,t=e.value,s=e.params.factor;if(e.init)if(e.state.pos=e.value,e.params.preserve){const s=t-e.getValue(e.time-a);e.state.vel=s/a}else e.state.vel=0;return e.state.vel+=(-s*(e.state.pos-t)-2*e.state.vel*Math.sqrt(s)*e.params.ratio)*a,e.state.pos+=e.state.vel*a,e.state.pos}};function s(e,a,t){const s=Math.max(t-Math.abs(e-a),0);return Math.min(e,a)-s*s*s/(6*t*t)}const r={name:"Clamp",description:"Constrain the curve between two values, featuring smooth minimum.",params:{min:{name:"Min",type:"float",default:0},max:{name:"Max",type:"float",default:1},smooth:{name:"Smooth",type:"float",default:0,min:0}},func(e){if(0===e.params.smooth)return a=e.value,t=e.params.min,r=e.params.max,Math.min(Math.max(a,t),r);var a,t,r;const o=-s(-e.params.min,-e.value,e.params.smooth);return s(e.params.max,o,e.params.smooth)}},o={name:"Exponential Smoothing",description:"Smooth the curve. Simple but good.",params:{factor:{name:"Factor",type:"float",default:10,min:0}},func(e){const a=e.value;e.init&&(e.state.pos=a);const t=Math.exp(-e.deltaTime*e.params.factor);return e.state.pos=e.state.pos*t+a*(1-t),e.state.pos}},n={name:"Gravity",description:"Accelerate and bounce the curve.",params:{a:{name:"Acceleration",type:"float",default:9.8},e:{name:"Restitution",type:"float",default:.5,min:0},preserve:{name:"Preserve Velocity",type:"boolean",default:!1}},func(e){const a=e.deltaTime,t=e.value;if(e.init)if(e.state.pos=t,e.params.preserve){const s=t-e.getValue(e.time-a);e.state.vel=s/a}else e.state.vel=0;const s=Math.sign(t-e.state.pos)*e.params.a;return e.state.vel+=s*a,e.state.pos+=e.state.vel*a,Math.sign(s)!==Math.sign(t-e.state.pos)&&(e.state.vel*=-e.params.e,e.state.pos=t+e.params.e*(t-e.state.pos)),e.state.pos}},m={name:"Hermite Patch",description:"Patch a curve using hermite spline.",params:{},func(e){if(e.init){const a=e.deltaTime,t=e.getValue(e.t0),s=t-e.getValue(e.t0-a),r=e.getValue(e.t1),o=r-e.getValue(e.t1-a);e.state.p0=t,e.state.m0=s/a*e.length,e.state.p1=r,e.state.m1=o/a*e.length}const{p0:a,m0:t,p1:s,m1:r}=e.state,o=e.progress;return((2*o-3)*o*o+1)*a+((o-2)*o+1)*o*t+(-2*o+3)*o*o*s+(o-1)*o*o*r}},i={name:"Lo-Fi",description:"Make curve more crunchy.",params:{rate:{name:"Frame Rate",type:"float",default:10,min:0,max:1e3},relative:{name:"Relative",type:"boolean",default:!1},reso:{name:"Reso Per Unit",type:"float",default:.1,min:0,max:1e3},round:{name:"Round",type:"boolean",default:!1}},func(e){let a;a=0===e.params.rate?e.time:e.params.relative?e.t0+Math.floor((e.time-e.t0)*e.params.rate)/e.params.rate:Math.floor(e.time*e.params.rate)/e.params.rate;let t=e.getValue(a);return 0!==e.params.reso&&(t=Math.floor(t*e.params.reso+(e.params.round?.5:0))/e.params.reso),t}};const p=new class{constructor(e){this.__seed=1,this.set(e)}gen(e){return e&&this.set(e),this.__seed=this.__seed^this.__seed<<13,this.__seed=this.__seed^this.__seed>>>17,this.__seed=this.__seed^this.__seed<<5,this.__seed/Math.pow(2,32)+.5}set(e=1){this.__seed=e}},l={name:"Fractal Noise",description:"wiggle()",params:{recursion:{name:"Recursion",type:"int",default:4,min:1,max:99},freq:{name:"Frequency",type:"float",default:1,min:0},reso:{name:"Resolution",type:"float",default:8,min:1},seed:{name:"Seed",type:"int",default:1,min:0},amp:{name:"Amp",type:"float",default:.2}},func(e){if(e.init){p.gen(e.params.seed),e.state.table=new Float32Array(Math.floor(e.params.reso)+2);for(let a=1;a<e.params.reso;a++)e.state.table[a]=2*p.gen()-1}let a=e.value;const t=e.progress;for(let n=0;n<e.params.recursion;n++){const m=t*e.params.freq*e.params.reso*Math.pow(2,n)%e.params.reso,i=Math.floor(m),p=m-i,l=Math.pow(.5,n+1);a+=e.params.amp*l*(s=e.state.table[i],r=e.state.table[i+1],s+(o=p)*o*(3-2*o)*(r-s))}var s,r,o;return a}},u={name:"Power",description:"You got boost power!",params:{pow:{name:"Power",type:"float",default:2},bias:{name:"Bias",type:"float",default:0},positive:{name:"Force Positive",type:"boolean",default:!1}},func(e){const a=e.value-e.params.bias,t=e.params.positive?1:Math.sign(a);return Math.pow(Math.abs(a),e.params.pow)*t+e.params.bias}},f={name:"Repeat",description:"Repeat a section of the curve.",params:{interval:{name:"Interval",type:"float",default:1,min:0}},func:e=>e.getValue(e.t0+e.elapsed%e.params.interval)},c=2*Math.PI,d={name:"Sinewave",description:"Overlay a sinewave to the curve.",params:{amp:{name:"Amp",type:"float",default:.1},freq:{name:"Frequency",type:"float",default:5},phase:{name:"Phase",type:"float",default:0,min:0,max:1}},func(e){const a=e.value,t=e.progress*e.params.freq+e.params.phase;return a+e.params.amp*Math.sin(t*c)}};e.add=a,e.cds=t,e.clamp=r,e.exp=o,e.gravity=n,e.hermitePatch=m,e.lofi=i,e.noise=l,e.pow=u,e.repeat=f,e.sine=d,Object.defineProperty(e,"__esModule",{value:!0})}));

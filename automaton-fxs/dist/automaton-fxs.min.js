// (c) 2020 FMS_Cat - https://github.com/FMS-Cat/automaton/blob/master/LICENSE
!function(e,a){"object"==typeof exports&&"undefined"!=typeof module?a(exports):"function"==typeof define&&define.amd?define(["exports"],a):a((e="undefined"!=typeof globalThis?globalThis:e||self).AUTOMATON_FXS={})}(this,(function(e){"use strict";const a={name:"Add",description:"The simplest fx ever. Just add a constant value to the curve.",params:{value:{name:"Value",type:"float",default:1}},func:e=>e.value+e.params.value},t={name:"Critically Damped Spring",description:"Basically the best smoothing method. Shoutouts to Keijiro Takahashi",params:{factor:{name:"Factor",type:"float",default:100,min:0},ratio:{name:"Damp Ratio",type:"float",default:1},preserve:{name:"Preserve Velocity",type:"boolean",default:!1}},func(e){const a=e.deltaTime,t=e.value,s=e.params.factor;if(e.init)if(e.state.pos=e.value,e.params.preserve){const s=t-e.getValue(e.time-a);e.state.vel=s/a}else e.state.vel=0;return e.state.vel+=(-s*(e.state.pos-t)-2*e.state.vel*Math.sqrt(s)*e.params.ratio)*a,e.state.pos+=e.state.vel*a,e.state.pos}};function s(e,a,t){return Math.min(Math.max(e,a),t)}function o(e,a,t){const s=Math.max(t-Math.abs(e-a),0);return Math.min(e,a)-s*s*s/(6*t*t)}const r={name:"Clamp",description:"Constrain the curve between two values, featuring smooth minimum.",params:{min:{name:"Min",type:"float",default:0},max:{name:"Max",type:"float",default:1},smooth:{name:"Smooth",type:"float",default:0,min:0}},func(e){if(0===e.params.smooth)return s(e.value,e.params.min,e.params.max);const a=-o(-e.params.min,-e.value,e.params.smooth);return o(e.params.max,a,e.params.smooth)}},n={name:"Exponential Smoothing",description:"Smooth the curve. Simple but good.",params:{factor:{name:"Factor",type:"float",default:10,min:0}},func(e){const a=e.value;e.init&&(e.state.pos=a);const t=Math.exp(-e.deltaTime*e.params.factor);return e.state.pos=e.state.pos*t+a*(1-t),e.state.pos}},m={name:"Gravity",description:"Accelerate and bounce the curve.",params:{a:{name:"Acceleration",type:"float",default:9.8},e:{name:"Restitution",type:"float",default:.5,min:0},preserve:{name:"Preserve Velocity",type:"boolean",default:!1}},func(e){const a=e.deltaTime,t=e.value;if(e.init)if(e.state.pos=t,e.params.preserve){const s=t-e.getValue(e.time-a);e.state.vel=s/a}else e.state.vel=0;const s=Math.sign(t-e.state.pos)*e.params.a;return e.state.vel+=s*a,e.state.pos+=e.state.vel*a,Math.sign(s)!==Math.sign(t-e.state.pos)&&(e.state.vel*=-e.params.e,e.state.pos=t+e.params.e*(t-e.state.pos)),e.state.pos}},p={name:"Lo-Fi",description:"Make curve more crunchy.",params:{rate:{name:"Frame Rate",type:"float",default:10,min:0,max:1e3},relative:{name:"Relative",type:"boolean",default:!1},reso:{name:"Reso Per Unit",type:"float",default:10,min:0,max:1e3},round:{name:"Round",type:"boolean",default:!1}},func(e){let a;a=0===e.params.rate?e.time:e.params.relative?e.t0+Math.floor((e.time-e.t0)*e.params.rate)/e.params.rate:Math.floor(e.time*e.params.rate)/e.params.rate;let t=e.getValue(a);return 0!==e.params.reso&&(t=Math.floor(t*e.params.reso+(e.params.round?.5:0))/e.params.reso),t}};function i(e,a,t){return e+(a-e)*(t*t*(3-2*t))}class l{constructor(e){this.__seed=1,this.set(e)}gen(e){return e&&this.set(e),this.__seed=this.__seed^this.__seed<<13,this.__seed=this.__seed^this.__seed>>>17,this.__seed=this.__seed^this.__seed<<5,this.__seed/Math.pow(2,32)+.5}set(e=1){this.__seed=e}}const u=new l,f={name:"Fractal Noise",description:"wiggle()",params:{recursion:{name:"Recursion",type:"int",default:4,min:1,max:99},freq:{name:"Frequency",type:"float",default:1,min:0},reso:{name:"Resolution",type:"float",default:8,min:1},seed:{name:"Seed",type:"int",default:1,min:0},amp:{name:"Amp",type:"float",default:.2}},func(e){if(e.init){u.gen(e.params.seed),e.state.table=new Float32Array(Math.floor(e.params.reso)+2);for(let a=1;a<e.params.reso;a++)e.state.table[a]=2*u.gen()-1}let a=e.value;const t=e.progress;for(let s=0;s<e.params.recursion;s++){const o=t*e.params.freq*e.params.reso*Math.pow(2,s)%e.params.reso,r=Math.floor(o),n=o-r,m=Math.pow(.5,s+1);a+=e.params.amp*m*i(e.state.table[r],e.state.table[r+1],n)}return a}},c={name:"Power",description:"You got boost power!",params:{pow:{name:"Power",type:"float",default:2},bias:{name:"Bias",type:"float",default:0},positive:{name:"Force Positive",type:"boolean",default:!1}},func(e){const a=e.value-e.params.bias,t=e.params.positive?1:Math.sign(a);return Math.pow(Math.abs(a),e.params.pow)*t+e.params.bias}},d=2*Math.PI,h={name:"Sinewave",description:"Overlay a sinewave to the curve.",params:{amp:{name:"Amp",type:"float",default:.1},freq:{name:"Frequency",type:"float",default:5},phase:{name:"Phase",type:"float",default:0,min:0,max:1}},func(e){const a=e.value,t=e.progress*e.params.freq+e.params.phase;return a+e.params.amp*Math.sin(t*d)}};var v=Object.freeze({__proto__:null,add:a,cds:t,clamp:r,exp:n,gravity:m,lofi:p,noise:f,pow:c,sine:h});const y={name:"Add",description:"The simplest fx ever. Just add a constant value to the curve.",params:{value:{name:"Value",type:"float",default:1}},func:e=>e.value+e.params.value},g={name:"Critically Damped Spring",description:"Basically the best smoothing method. Shoutouts to Keijiro Takahashi",params:{factor:{name:"Factor",type:"float",default:100,min:0},ratio:{name:"Damp Ratio",type:"float",default:1},preserve:{name:"Preserve Velocity",type:"boolean",default:!1}},func(e){const a=e.deltaTime,t=e.value,s=e.params.factor;if(e.init)if(e.state.pos=e.value,e.params.preserve){const s=t-e.getValue(e.time-a);e.state.vel=s/a}else e.state.vel=0;return e.state.vel+=(-s*(e.state.pos-t)-2*e.state.vel*Math.sqrt(s)*e.params.ratio)*a,e.state.pos+=e.state.vel*a,e.state.pos}},M={name:"Clamp",description:"Constrain the curve between two values, featuring smooth minimum.",params:{min:{name:"Min",type:"float",default:0},max:{name:"Max",type:"float",default:1},smooth:{name:"Smooth",type:"float",default:0,min:0}},func(e){if(0===e.params.smooth)return s(e.value,e.params.min,e.params.max);const a=-o(-e.params.min,-e.value,e.params.smooth);return o(e.params.max,a,e.params.smooth)}},b={name:"Exponential Smoothing",description:"Smooth the curve. Simple but good.",params:{factor:{name:"Factor",type:"float",default:10,min:0}},func(e){const a=e.value;e.init&&(e.state.pos=a);const t=Math.exp(-e.deltaTime*e.params.factor);return e.state.pos=e.state.pos*t+a*(1-t),e.state.pos}},w={name:"Gravity",description:"Accelerate and bounce the curve.",params:{a:{name:"Acceleration",type:"float",default:9.8},e:{name:"Restitution",type:"float",default:.5,min:0},preserve:{name:"Preserve Velocity",type:"boolean",default:!1}},func(e){const a=e.deltaTime,t=e.value;if(e.init)if(e.state.pos=t,e.params.preserve){const s=t-e.getValue(e.time-a);e.state.vel=s/a}else e.state.vel=0;const s=Math.sign(t-e.state.pos)*e.params.a;return e.state.vel+=s*a,e.state.pos+=e.state.vel*a,Math.sign(s)!==Math.sign(t-e.state.pos)&&(e.state.vel*=-e.params.e,e.state.pos=t+e.params.e*(t-e.state.pos)),e.state.pos}},_={name:"Hermite Patch",description:"Patch a curve using hermite spline.",params:{},func(e){if(e.init){const a=e.deltaTime,t=e.getValue(e.t0),s=t-e.getValue(e.t0-a),o=e.getValue(e.t1),r=o-e.getValue(e.t1-a);e.state.p0=t,e.state.m0=s/a*e.length,e.state.p1=o,e.state.m1=r/a*e.length}const{p0:a,m0:t,p1:s,m1:o}=e.state,r=e.progress;return((2*r-3)*r*r+1)*a+((r-2)*r+1)*r*t+(-2*r+3)*r*r*s+(r-1)*r*r*o}},x={name:"Lo-Fi",description:"Make curve more crunchy.",params:{rate:{name:"Frame Rate",type:"float",default:10,min:0,max:1e3},relative:{name:"Relative",type:"boolean",default:!1},reso:{name:"Reso Per Unit",type:"float",default:10,min:0,max:1e3},round:{name:"Round",type:"boolean",default:!1}},func(e){let a;a=0===e.params.rate?e.time:e.params.relative?e.t0+Math.floor((e.time-e.t0)*e.params.rate)/e.params.rate:Math.floor(e.time*e.params.rate)/e.params.rate;let t=e.getValue(a);return 0!==e.params.reso&&(t=Math.floor(t*e.params.reso+(e.params.round?.5:0))/e.params.reso),t}},F=new l,P={name:"Fractal Noise",description:"wiggle()",params:{recursion:{name:"Recursion",type:"int",default:4,min:1,max:99},freq:{name:"Frequency",type:"float",default:1,min:0},reso:{name:"Resolution",type:"float",default:8,min:1},seed:{name:"Seed",type:"int",default:1,min:0},amp:{name:"Amp",type:"float",default:.2}},func(e){if(e.init){F.gen(e.params.seed),e.state.table=new Float32Array(Math.floor(e.params.reso)+2);for(let a=1;a<e.params.reso;a++)e.state.table[a]=2*F.gen()-1}let a=e.value;const t=e.progress;for(let s=0;s<e.params.recursion;s++){const o=t*e.params.freq*e.params.reso*Math.pow(2,s)%e.params.reso,r=Math.floor(o),n=o-r,m=Math.pow(.5,s+1);a+=e.params.amp*m*i(e.state.table[r],e.state.table[r+1],n)}return a}},R={name:"Power",description:"You got boost power!",params:{pow:{name:"Power",type:"float",default:2},bias:{name:"Bias",type:"float",default:0},positive:{name:"Force Positive",type:"boolean",default:!1}},func(e){const a=e.value-e.params.bias,t=e.params.positive?1:Math.sign(a);return Math.pow(Math.abs(a),e.params.pow)*t+e.params.bias}},S={name:"Repeat",description:"Repeat a section of the curve.",params:{interval:{name:"Interval",type:"float",default:1,min:0}},func:e=>e.getValue(e.t0+e.elapsed%e.params.interval)},V=2*Math.PI,T={name:"Sinewave",description:"Overlay a sinewave to the curve.",params:{amp:{name:"Amp",type:"float",default:.1},freq:{name:"Frequency",type:"float",default:5},offset:{name:"Offset",type:"float",default:0,min:0,max:1}},func(e){const a=e.value,t=e.elapsed*e.params.freq+e.params.offset;return a+e.params.amp*Math.sin(t*V)}};e.add=y,e.cds=g,e.clamp=M,e.exp=b,e.gravity=w,e.hermitePatch=_,e.lofi=x,e.noise=P,e.pow=R,e.repeat=S,e.sine=T,e.v2compat=v,Object.defineProperty(e,"__esModule",{value:!0})}));

// (c) 2020 FMS_Cat - https://github.com/FMS-Cat/automaton/blob/master/LICENSE
const e={name:"Add",description:"The simplest fx ever. Just add a constant value to the curve.",params:{value:{name:"Value",type:"float",default:1}},func:e=>e.value+e.params.value},a={name:"Critically Damped Spring",description:"Basically the best smoothing method. Shoutouts to Keijiro Takahashi",params:{factor:{name:"Factor",type:"float",default:100,min:0},ratio:{name:"Damp Ratio",type:"float",default:1},preserve:{name:"Preserve Velocity",type:"boolean",default:!1}},func(e){const a=e.deltaTime,t=e.value,s=e.params.factor;if(e.init)if(e.state.pos=e.value,e.params.preserve){const s=t-e.getValue(e.time-a);e.state.vel=s/a}else e.state.vel=0;return e.state.vel+=(-s*(e.state.pos-t)-2*e.state.vel*Math.sqrt(s)*e.params.ratio)*a,e.state.pos+=e.state.vel*a,e.state.pos}};function t(e,a,t){return Math.min(Math.max(e,a),t)}function s(e,a,t){const s=Math.max(t-Math.abs(e-a),0);return Math.min(e,a)-s*s*s/(6*t*t)}const r={name:"Clamp",description:"Constrain the curve between two values, featuring smooth minimum.",params:{min:{name:"Min",type:"float",default:0},max:{name:"Max",type:"float",default:1},smooth:{name:"Smooth",type:"float",default:0,min:0}},func(e){if(0===e.params.smooth)return t(e.value,e.params.min,e.params.max);const a=-s(-e.params.min,-e.value,e.params.smooth);return s(e.params.max,a,e.params.smooth)}},o={name:"Exponential Smoothing",description:"Smooth the curve. Simple but good.",params:{factor:{name:"Factor",type:"float",default:10,min:0}},func(e){const a=e.value;e.init&&(e.state.pos=a);const t=Math.exp(-e.deltaTime*e.params.factor);return e.state.pos=e.state.pos*t+a*(1-t),e.state.pos}},n={name:"Gravity",description:"Accelerate and bounce the curve.",params:{a:{name:"Acceleration",type:"float",default:9.8},e:{name:"Restitution",type:"float",default:.5,min:0},preserve:{name:"Preserve Velocity",type:"boolean",default:!1}},func(e){const a=e.deltaTime,t=e.value;if(e.init)if(e.state.pos=t,e.params.preserve){const s=t-e.getValue(e.time-a);e.state.vel=s/a}else e.state.vel=0;const s=Math.sign(t-e.state.pos)*e.params.a;return e.state.vel+=s*a,e.state.pos+=e.state.vel*a,Math.sign(s)!==Math.sign(t-e.state.pos)&&(e.state.vel*=-e.params.e,e.state.pos=t+e.params.e*(t-e.state.pos)),e.state.pos}},m={name:"Lo-Fi",description:"Make curve more crunchy.",params:{rate:{name:"Frame Rate",type:"float",default:10,min:0,max:1e3},relative:{name:"Relative",type:"boolean",default:!1},reso:{name:"Reso Per Unit",type:"float",default:10,min:0,max:1e3},round:{name:"Round",type:"boolean",default:!1}},func(e){let a;a=0===e.params.rate?e.time:e.params.relative?e.t0+Math.floor((e.time-e.t0)*e.params.rate)/e.params.rate:Math.floor(e.time*e.params.rate)/e.params.rate;let t=e.getValue(a);return 0!==e.params.reso&&(t=Math.floor(t*e.params.reso+(e.params.round?.5:0))/e.params.reso),t}};function p(e,a,t){return e+(a-e)*(t*t*(3-2*t))}class i{constructor(e){this.__seed=1,this.set(e)}gen(e){return e&&this.set(e),this.__seed=this.__seed^this.__seed<<13,this.__seed=this.__seed^this.__seed>>>17,this.__seed=this.__seed^this.__seed<<5,this.__seed/Math.pow(2,32)+.5}set(e=1){this.__seed=e}}const l=new i,u={name:"Fractal Noise",description:"wiggle()",params:{recursion:{name:"Recursion",type:"int",default:4,min:1,max:99},freq:{name:"Frequency",type:"float",default:1,min:0},reso:{name:"Resolution",type:"float",default:8,min:1},seed:{name:"Seed",type:"int",default:1,min:0},amp:{name:"Amp",type:"float",default:.2}},func(e){if(e.init){l.gen(e.params.seed),e.state.table=new Float32Array(Math.floor(e.params.reso)+2);for(let a=1;a<e.params.reso;a++)e.state.table[a]=2*l.gen()-1}let a=e.value;const t=e.progress;for(let s=0;s<e.params.recursion;s++){const r=t*e.params.freq*e.params.reso*Math.pow(2,s)%e.params.reso,o=Math.floor(r),n=r-o,m=Math.pow(.5,s+1);a+=e.params.amp*m*p(e.state.table[o],e.state.table[o+1],n)}return a}},f={name:"Power",description:"You got boost power!",params:{pow:{name:"Power",type:"float",default:2},bias:{name:"Bias",type:"float",default:0},positive:{name:"Force Positive",type:"boolean",default:!1}},func(e){const a=e.value-e.params.bias,t=e.params.positive?1:Math.sign(a);return Math.pow(Math.abs(a),e.params.pow)*t+e.params.bias}},c=2*Math.PI,d={name:"Sinewave",description:"Overlay a sinewave to the curve.",params:{amp:{name:"Amp",type:"float",default:.1},freq:{name:"Frequency",type:"float",default:5},phase:{name:"Phase",type:"float",default:0,min:0,max:1}},func(e){const a=e.value,t=e.progress*e.params.freq+e.params.phase;return a+e.params.amp*Math.sin(t*c)}};var h=Object.freeze({__proto__:null,add:e,cds:a,clamp:r,exp:o,gravity:n,lofi:m,noise:u,pow:f,sine:d});const v={name:"Add",description:"The simplest fx ever. Just add a constant value to the curve.",params:{value:{name:"Value",type:"float",default:1}},func:e=>e.value+e.params.value},y={name:"Critically Damped Spring",description:"Basically the best smoothing method. Shoutouts to Keijiro Takahashi",params:{factor:{name:"Factor",type:"float",default:100,min:0},ratio:{name:"Damp Ratio",type:"float",default:1},preserve:{name:"Preserve Velocity",type:"boolean",default:!1}},func(e){const a=e.deltaTime,t=e.value,s=e.params.factor;if(e.init)if(e.state.pos=e.value,e.params.preserve){const s=t-e.getValue(e.time-a);e.state.vel=s/a}else e.state.vel=0;return e.state.vel+=(-s*(e.state.pos-t)-2*e.state.vel*Math.sqrt(s)*e.params.ratio)*a,e.state.pos+=e.state.vel*a,e.state.pos}},g={name:"Clamp",description:"Constrain the curve between two values, featuring smooth minimum.",params:{min:{name:"Min",type:"float",default:0},max:{name:"Max",type:"float",default:1},smooth:{name:"Smooth",type:"float",default:0,min:0}},func(e){if(0===e.params.smooth)return t(e.value,e.params.min,e.params.max);const a=-s(-e.params.min,-e.value,e.params.smooth);return s(e.params.max,a,e.params.smooth)}},M={name:"Exponential Smoothing",description:"Smooth the curve. Simple but good.",params:{factor:{name:"Factor",type:"float",default:10,min:0}},func(e){const a=e.value;e.init&&(e.state.pos=a);const t=Math.exp(-e.deltaTime*e.params.factor);return e.state.pos=e.state.pos*t+a*(1-t),e.state.pos}},b={name:"Gravity",description:"Accelerate and bounce the curve.",params:{a:{name:"Acceleration",type:"float",default:9.8},e:{name:"Restitution",type:"float",default:.5,min:0},preserve:{name:"Preserve Velocity",type:"boolean",default:!1}},func(e){const a=e.deltaTime,t=e.value;if(e.init)if(e.state.pos=t,e.params.preserve){const s=t-e.getValue(e.time-a);e.state.vel=s/a}else e.state.vel=0;const s=Math.sign(t-e.state.pos)*e.params.a;return e.state.vel+=s*a,e.state.pos+=e.state.vel*a,Math.sign(s)!==Math.sign(t-e.state.pos)&&(e.state.vel*=-e.params.e,e.state.pos=t+e.params.e*(t-e.state.pos)),e.state.pos}},w={name:"Hermite Patch",description:"Patch a curve using hermite spline.",params:{},func(e){if(e.init){const a=e.deltaTime,t=e.getValue(e.t0),s=t-e.getValue(e.t0-a),r=e.getValue(e.t1),o=r-e.getValue(e.t1-a);e.state.p0=t,e.state.m0=s/a*e.length,e.state.p1=r,e.state.m1=o/a*e.length}const{p0:a,m0:t,p1:s,m1:r}=e.state,o=e.progress;return((2*o-3)*o*o+1)*a+((o-2)*o+1)*o*t+(-2*o+3)*o*o*s+(o-1)*o*o*r}},_={name:"Lo-Fi",description:"Make curve more crunchy.",params:{rate:{name:"Frame Rate",type:"float",default:10,min:0,max:1e3},relative:{name:"Relative",type:"boolean",default:!1},reso:{name:"Reso Per Unit",type:"float",default:10,min:0,max:1e3},round:{name:"Round",type:"boolean",default:!1}},func(e){let a;a=0===e.params.rate?e.time:e.params.relative?e.t0+Math.floor((e.time-e.t0)*e.params.rate)/e.params.rate:Math.floor(e.time*e.params.rate)/e.params.rate;let t=e.getValue(a);return 0!==e.params.reso&&(t=Math.floor(t*e.params.reso+(e.params.round?.5:0))/e.params.reso),t}},x=new i,F={name:"Fractal Noise",description:"wiggle()",params:{recursion:{name:"Recursion",type:"int",default:4,min:1,max:99},freq:{name:"Frequency",type:"float",default:1,min:0},reso:{name:"Resolution",type:"float",default:8,min:1},seed:{name:"Seed",type:"int",default:1,min:0},amp:{name:"Amp",type:"float",default:.2}},func(e){if(e.init){x.gen(e.params.seed),e.state.table=new Float32Array(Math.floor(e.params.reso)+2);for(let a=1;a<e.params.reso;a++)e.state.table[a]=2*x.gen()-1}let a=e.value;const t=e.progress;for(let s=0;s<e.params.recursion;s++){const r=t*e.params.freq*e.params.reso*Math.pow(2,s)%e.params.reso,o=Math.floor(r),n=r-o,m=Math.pow(.5,s+1);a+=e.params.amp*m*p(e.state.table[o],e.state.table[o+1],n)}return a}},R={name:"Power",description:"You got boost power!",params:{pow:{name:"Power",type:"float",default:2},bias:{name:"Bias",type:"float",default:0},positive:{name:"Force Positive",type:"boolean",default:!1}},func(e){const a=e.value-e.params.bias,t=e.params.positive?1:Math.sign(a);return Math.pow(Math.abs(a),e.params.pow)*t+e.params.bias}},P={name:"Repeat",description:"Repeat a section of the curve.",params:{interval:{name:"Interval",type:"float",default:1,min:0}},func:e=>e.getValue(e.t0+e.elapsed%e.params.interval)},V=2*Math.PI,S={name:"Sinewave",description:"Overlay a sinewave to the curve.",params:{amp:{name:"Amp",type:"float",default:.1},freq:{name:"Frequency",type:"float",default:5},offset:{name:"Offset",type:"float",default:0,min:0,max:1}},func(e){const a=e.value,t=e.elapsed*e.params.freq+e.params.offset;return a+e.params.amp*Math.sin(t*V)}};export{v as add,y as cds,g as clamp,M as exp,b as gravity,w as hermitePatch,_ as lofi,F as noise,R as pow,P as repeat,S as sine,h as v2compat};

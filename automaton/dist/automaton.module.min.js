/*! (c) 2017-2021 0b5vr - https://github.com/0b5vr/automaton/blob/master/LICENSE */
const t=[];function e(t,e,i){return Math.min(Math.max(t,e),i)}function i(t){return t.p3-3*t.p2+3*t.p1-t.p0}function s(t){return 3*t.p2-6*t.p1+3*t.p0}function n(t){return 3*t.p1-3*t.p0}function l(t,e){return((i(e)*t+s(e))*t+n(e))*t+e.p0}function o(t,e){return(3*i(e)*t+2*s(e))*t+n(e)}function h(i,s,n){if(n<=i.p0)return s.p0;if(i.p3<=n)return s.p3;i.p1=e(i.p1,i.p0,i.p3),i.p2=e(i.p2,i.p0,i.p3);for(let e=0;e<21;e++)t[e]=l(e/20,i);let h=0;for(let e=1;e<21&&(h=e-1,!(n<t[e]));e++);let r=(h+(n-t[h])/(t[h+1]-t[h]))/20;const u=o(r,i)/(i.p3-i.p0);return.001<=u?r=function(t,e,i){for(let s=0;s<4;s++){const s=o(e,i);if(0===s)return e;e-=(l(e,i)-t)/s}return e}(n,r,i):0!==u&&(r=function(t,e,i,s){let n=0,o=0;for(let h=0;h<10&&(o=e+(i-e)/2,n=l(o,s)-t,0<n?i=o:e=o,!(1e-6<Math.abs(n)));h++);return o}(n,h/20,(h+1)/20,i)),l(r,s)}function r(t,e,i){return h({p0:t.time,p1:t.time+t.outTime,p2:e.time+e.inTime,p3:e.time},{p0:t.value,p1:t.value+t.outValue,p2:e.value+e.inValue,p3:e.value},i)}function u(t,e){if("function"!=typeof e)return u(t,(t=>t<e));const i=e;let s=0,n=t.length;for(;s<n;){const e=s+n>>1;i(t[e])?s=e+1:n=e}return s}class a{constructor(t,e){this.__automaton=t,this.deserialize(e)}get end(){return this.time+this.length}getValue(t){if(this.reset&&this.length<=t)return 0;if(this.curve){const e=this.offset+t*this.speed;return this.value+this.amp*this.curve.getValue(e)}return this.value}deserialize(t){var e,i,s,n,l,o,h,r;this.time=null!==(e=t.time)&&void 0!==e?e:0,this.length=null!==(i=t.length)&&void 0!==i?i:0,this.value=null!==(s=t.value)&&void 0!==s?s:0,this.offset=null!==(n=t.offset)&&void 0!==n?n:0,this.speed=null!==(l=t.speed)&&void 0!==l?l:1,this.amp=null!==(o=t.amp)&&void 0!==o?o:1,this.reset=t.reset,null!=t.curve&&(this.curve=this.__automaton.getCurve(t.curve),this.length=null!==(r=null!==(h=t.length)&&void 0!==h?h:this.curve.length)&&void 0!==r?r:0)}}class _{constructor(t,e){this.__items=[],this.__value=0,this.__time=-1/0,this.__head=0,this.__listeners=[],this.__automaton=t,this.deserialize(e)}get currentValue(){return this.__value}get currentTime(){return this.__time}deserialize(t){var e,i;this.__items=null!==(i=null===(e=t.items)||void 0===e?void 0:e.map((t=>new a(this.__automaton,t))))&&void 0!==i?i:[]}reset(){this.__time=-1/0,this.__value=0,this.__head=0}subscribe(t){this.__listeners.push(t)}getValue(t){if(0===this.__items.length)return 0;const e=u(this.__items,(e=>e.time<t));if(0===e)return 0;const i=this.__items[e-1];return i.end<t?i.getValue(i.length):i.getValue(t-i.time)}consume(t){const e=[],i=this.__time;for(let s=this.__head;s<this.__items.length;s++){const n=this.__items[s],{time:l,end:o,length:h}=n;let r=t-l;if(r<0)break;{let u,a,_;h<=r?(r=h,u=1,_=!0,s===this.__head&&this.__head++):u=0!==h?r/h:1,i<l&&(a=!0),e.push([l+r,()=>{this.__value=n.getValue(r),this.__listeners.forEach((e=>e({time:t,elapsed:r,begin:l,end:o,length:h,value:this.__value,progress:u,init:a,uninit:_})))}])}}return this.__time=t,e}}class c{constructor(t,e){this.__nodes=[],this.__fxs=[],this.__automaton=t,this.deserialize(e)}get length(){return this.__nodes[this.__nodes.length-1].time}deserialize(t){var e;this.__nodes=t.nodes.map((t=>{var e,i,s,n,l,o;return{time:null!==(e=t[0])&&void 0!==e?e:0,value:null!==(i=t[1])&&void 0!==i?i:0,inTime:null!==(s=t[2])&&void 0!==s?s:0,inValue:null!==(n=t[3])&&void 0!==n?n:0,outTime:null!==(l=t[4])&&void 0!==l?l:0,outValue:null!==(o=t[5])&&void 0!==o?o:0}})),this.__fxs=[],null===(e=t.fxs)||void 0===e||e.forEach((t=>{var e,i,s;t.bypass||this.__fxs.push({time:null!==(e=t.time)&&void 0!==e?e:0,length:null!==(i=t.length)&&void 0!==i?i:0,row:null!==(s=t.row)&&void 0!==s?s:0,def:t.def,params:t.params})})),this.precalc()}precalc(){const t=Math.ceil(this.__automaton.resolution*this.length)+1;this.__values=new Float32Array(t),this.__shouldNotInterpolate=new Uint8Array(t),this.__generateCurve(),this.__applyFxs()}getValue(t){if(t<0)return this.__values[0];if(this.length<=t)return this.__values[this.__values.length-1];{const e=t*this.__automaton.resolution,i=Math.floor(e),s=e%1,n=this.__values[i];let l=this.__values[i+1];if(this.__shouldNotInterpolate[i]){l=2*n-this.__values[Math.max(i-1,0)]}return n+(l-n)*s}}__generateCurve(){let t=this.__nodes[0],e=0;for(let i=0;i<this.__nodes.length-1;i++){const s=t;t=this.__nodes[i+1];const n=e;if(e=Math.floor(t.time*this.__automaton.resolution),this.__values[n]=s.value,n===e&&0!==e)this.__shouldNotInterpolate[e-1]=1;else for(let i=n+1;i<=e;i++){const e=r(s,t,i/this.__automaton.resolution);this.__values[i]=e}}for(let i=e+1;i<this.__values.length;i++)this.__values[i]=t.value}__applyFxs(){for(let t=0;t<this.__fxs.length;t++){const e=this.__fxs[t],i=this.__automaton.getFxDefinition(e.def);if(!i)continue;const s=Math.min(this.length,e.time+e.length),n=Math.ceil(this.__automaton.resolution*e.time),l=Math.floor(this.__automaton.resolution*s);if(l<=n)continue;const o=l-n+1,h=new Float32Array(o),r={index:n,i0:n,i1:l,time:e.time,t0:e.time,t1:e.time+e.length,deltaTime:1/this.__automaton.resolution,value:0,progress:0,elapsed:0,resolution:this.__automaton.resolution,length:e.length,params:e.params,array:this.__values,shouldNotInterpolate:1===this.__shouldNotInterpolate[n],setShouldNotInterpolate:t=>{this.__shouldNotInterpolate[r.index]=t?1:0},getValue:this.getValue.bind(this),init:!0,state:{}};for(let t=0;t<o;t++)r.index=t+n,r.time=r.index/this.__automaton.resolution,r.value=this.__values[t+n],r.elapsed=r.time-e.time,r.progress=r.elapsed/e.length,r.shouldNotInterpolate=1===this.__shouldNotInterpolate[t+n],h[t]=i.func(r),r.init=!1;this.__values.set(h,n)}}}class m{constructor(t,e={}){this.auto=this.__auto.bind(this),this.curves=[],this.channels=[],this.mapNameToChannel=new Map,this.__time=0,this.__version="4.2.1",this.__resolution=1e3,this.__fxDefinitions={},e.fxDefinitions&&this.addFxDefinitions(e.fxDefinitions),this.deserialize(t)}get time(){return this.__time}get version(){return this.__version}get resolution(){return this.__resolution}deserialize(t){this.__resolution=t.resolution,this.curves.splice(0),this.curves.push(...t.curves.map((t=>new c(this,t)))),this.mapNameToChannel.clear(),this.channels.splice(0),this.channels.push(...t.channels.map((([t,e])=>{const i=new _(this,e);return this.mapNameToChannel.set(t,i),i})))}addFxDefinitions(t){Object.entries(t).forEach((([t,e])=>{"function"==typeof e.func&&(this.__fxDefinitions[t]=e)})),this.precalcAll()}getFxDefinition(t){return this.__fxDefinitions[t]||null}getCurve(t){return this.curves[t]||null}precalcAll(){Object.values(this.curves).forEach((t=>t.precalc()))}reset(){Object.values(this.channels).forEach((t=>t.reset()))}update(t){const e=Math.max(t,0);this.__time=e;this.channels.map((t=>t.consume(this.__time))).flat(1).sort((([t],[e])=>t-e)).forEach((([t,e])=>e()))}__auto(t,e){const i=this.mapNameToChannel.get(t);return e&&i.subscribe(e),i.currentValue}}export{m as Automaton,_ as Channel,a as ChannelItem,c as Curve,r as bezierEasing,u as binarySearch};
